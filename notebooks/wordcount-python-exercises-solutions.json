{
  "paragraphs": [
    {
      "text": "%md\n## \"Word Count\" Exercises Solutions (PySpark)\n**IMPORTANT**: Remember that the best way to learn is by doing. So, if you haven't yet tried to complete the exercises on your own, give them a try before looking at the following solutions.\n\nWe'll begin by loading once again the documents for further processing and reusing the `toWords` and `countWords` functions that we saw during the session:",
      "user": "anonymous",
      "dateUpdated": "2018-08-07 19:52:11.095",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "colWidth": 12.0,
        "editorMode": "ace/mode/markdown",
        "fontSize": 9.0,
        "editorHide": true,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<h2>&ldquo;Word Count&rdquo; Exercises Solutions (PySpark)</h2>\n<p><strong>IMPORTANT</strong>: Remember that the best way to learn is by doing. So, if you haven&rsquo;t yet tried to complete the exercises on your own, give them a try before looking at the following solutions.</p>\n<p>We&rsquo;ll begin by loading once again the documents for further processing and reusing the <code>toWords</code> and <code>countWords</code> functions that we saw during the session:</p>\n</div>"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533679361427_-19581483",
      "id": "20180717-203836_1864110548",
      "dateCreated": "2018-08-07 17:02:41.427",
      "dateStarted": "2018-08-07 19:52:11.111",
      "dateFinished": "2018-08-07 19:52:11.115",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%pyspark\nfrom pyspark.sql.functions import split, explode, col, lower\n\ndef to_words(documents, separators_regexp=r'\\s+'):\n    words = (documents\n        .select(explode(split(documents.value, separators_regexp)).alias('word'))\n        .select(lower(col('word')).alias('word'))\n        .where(col('word') != ''))\n    return words",
      "user": "anonymous",
      "dateUpdated": "2018-08-07 19:52:11.216",
      "config": {
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12.0,
        "editorMode": "ace/mode/python",
        "fontSize": 9.0,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": []
      },
      "apps": [],
      "jobName": "paragraph_1533679361429_-1302218006",
      "id": "20180717-204348_1084183229",
      "dateCreated": "2018-08-07 17:02:41.429",
      "dateStarted": "2018-08-07 19:52:11.232",
      "dateFinished": "2018-08-07 19:52:11.237",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%pyspark\ndef count_words(documents, separators_regexp=r'\\s+'):\n    words = to_words(documents, separators_regexp)\n    counts = words.groupBy(\"word\").count()\n    return counts",
      "user": "anonymous",
      "dateUpdated": "2018-08-07 19:52:11.335",
      "config": {
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12.0,
        "editorMode": "ace/mode/python",
        "fontSize": 9.0,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": []
      },
      "apps": [],
      "jobName": "paragraph_1533679361429_-1402351480",
      "id": "20180717-204246_1526665935",
      "dateCreated": "2018-08-07 17:02:41.429",
      "dateStarted": "2018-08-07 19:52:11.353",
      "dateFinished": "2018-08-07 19:52:11.357",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%pyspark\ndocuments = sqlContext.read.text(\"gs://de-training-input-bucket/words/big.txt\")\ndocuments.show()",
      "user": "anonymous",
      "dateUpdated": "2018-08-07 19:52:11.454",
      "config": {
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12.0,
        "editorMode": "ace/mode/python",
        "fontSize": 9.0,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "+--------------------+\n|               value|\n+--------------------+\n|The Project Guten...|\n|by Sir Arthur Con...|\n|(#15 in our serie...|\n|                    |\n|Copyright laws ar...|\n|copyright laws fo...|\n|this or any other...|\n|                    |\n|This header shoul...|\n|Gutenberg file.  ...|\n|header without wr...|\n|                    |\n|Please read the \"...|\n|eBook and Project...|\n|important informa...|\n|how the file may ...|\n|donation to Proje...|\n|                    |\n|                    |\n|**Welcome To The ...|\n+--------------------+\nonly showing top 20 rows\n\n"
          }
        ]
      },
      "runtimeInfos": {
        "jobUrl": {
          "propertyName": "jobUrl",
          "label": "SPARK JOB",
          "tooltip": "View in Spark web UI",
          "group": "spark",
          "values": [
            "http://172.16.14.143:4040/jobs/job?id=58"
          ],
          "interpreterSettingId": "spark"
        }
      },
      "apps": [],
      "jobName": "paragraph_1533679361430_-2019520942",
      "id": "20180801-191544_1437593776",
      "dateCreated": "2018-08-07 17:02:41.430",
      "dateStarted": "2018-08-07 19:52:11.471",
      "dateFinished": "2018-08-07 19:52:15.454",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n### Can you count the number of characters in the set of documents?",
      "user": "anonymous",
      "dateUpdated": "2018-08-07 19:52:15.467",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "colWidth": 12.0,
        "editorMode": "ace/mode/markdown",
        "fontSize": 9.0,
        "editorHide": true,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<h3>Can you count the number of characters in the set of documents?</h3>\n</div>"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533679361430_-793426760",
      "id": "20180731-120654_421946737",
      "dateCreated": "2018-08-07 17:02:41.430",
      "dateStarted": "2018-08-07 19:52:15.484",
      "dateFinished": "2018-08-07 19:52:15.487",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\nThis is exactly the same problem as the example the instructor demonstrated! There’s only a slight twist— rather than splitting the text into words, we need to split it into characters. Let's see how we can accomplish this by modifying the above functions:",
      "user": "anonymous",
      "dateUpdated": "2018-08-07 19:52:15.588",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "colWidth": 12.0,
        "editorMode": "ace/mode/markdown",
        "fontSize": 9.0,
        "editorHide": true,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>This is exactly the same problem as the example the instructor demonstrated! There’s only a slight twist— rather than splitting the text into words, we need to split it into characters. Let&rsquo;s see how we can accomplish this by modifying the above functions:</p>\n</div>"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533679361430_-707485857",
      "id": "20180731-120820_2145672945",
      "dateCreated": "2018-08-07 17:02:41.430",
      "dateStarted": "2018-08-07 19:52:15.606",
      "dateFinished": "2018-08-07 19:52:15.609",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%pyspark\ndef to_chars(documents, pattern=r'.'):\n    chars = (\n        documents\n        .select(explode(split(documents.value, '')).alias('char'))\n        .select(lower(col('char')).alias('char'))\n        .where(col('char').rlike(pattern))\n    )\n    return chars",
      "user": "anonymous",
      "dateUpdated": "2018-08-07 19:52:15.707",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12.0,
        "editorMode": "ace/mode/python",
        "fontSize": 9.0,
        "editorHide": false,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": []
      },
      "apps": [],
      "jobName": "paragraph_1533679361431_137274071",
      "id": "20180731-122059_1223178467",
      "dateCreated": "2018-08-07 17:02:41.431",
      "dateStarted": "2018-08-07 19:52:15.726",
      "dateFinished": "2018-08-07 19:52:15.731",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\nNotice we added a `pattern` optional parameter that can come in handy if we want to restrict the characters that we analyze.",
      "user": "anonymous",
      "dateUpdated": "2018-08-07 19:52:15.829",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "colWidth": 12.0,
        "editorMode": "ace/mode/markdown",
        "fontSize": 9.0,
        "editorHide": true,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>Notice we added a <code>pattern</code> optional parameter that can come in handy if we want to restrict the characters that we analyze.</p>\n</div>"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533679361431_-1930441670",
      "id": "20180731-123035_1116141343",
      "dateCreated": "2018-08-07 17:02:41.431",
      "dateStarted": "2018-08-07 19:52:15.844",
      "dateFinished": "2018-08-07 19:52:15.846",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%pyspark\ndef count_chars(documents, pattern=r'.'):\n    chars = to_chars(documents, pattern=pattern)\n    counts = chars.groupBy(\"char\").count()\n    return counts",
      "user": "anonymous",
      "dateUpdated": "2018-08-07 19:52:15.948",
      "config": {
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12.0,
        "editorMode": "ace/mode/python",
        "fontSize": 9.0,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": []
      },
      "apps": [],
      "jobName": "paragraph_1533679361431_850188457",
      "id": "20180731-122755_1332441437",
      "dateCreated": "2018-08-07 17:02:41.431",
      "dateStarted": "2018-08-07 19:52:15.963",
      "dateFinished": "2018-08-07 19:52:15.967",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\nLet's give these functions a try:",
      "user": "anonymous",
      "dateUpdated": "2018-08-07 19:52:16.067",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "colWidth": 12.0,
        "editorMode": "ace/mode/markdown",
        "fontSize": 9.0,
        "editorHide": true,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>Let&rsquo;s give these functions a try:</p>\n</div>"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533679361431_-602159965",
      "id": "20180731-225055_649861773",
      "dateCreated": "2018-08-07 17:02:41.431",
      "dateStarted": "2018-08-07 19:52:16.086",
      "dateFinished": "2018-08-07 19:52:16.088",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%pyspark\nchars = count_chars(documents)\nchars.show()",
      "user": "anonymous",
      "dateUpdated": "2018-08-07 19:52:16.189",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12.0,
        "editorMode": "ace/mode/python",
        "fontSize": 9.0,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "+----+------+\n|char| count|\n+----+------+\n|   7|  1890|\n|   ~|     2|\n|   l|198648|\n|   ;|  3511|\n|   x|  9810|\n|   =|  1764|\n|   <|     2|\n|   ]|   435|\n|   g| 96916|\n|   3|  2492|\n|   8|  2527|\n|   +|    91|\n|   *|   489|\n|   0|  3064|\n|   m|127063|\n|   !|  4345|\n|   \t|    12|\n|   f|120875|\n|   5|  2192|\n|   (|  1748|\n+----+------+\nonly showing top 20 rows\n\n"
          }
        ]
      },
      "runtimeInfos": {
        "jobUrl": {
          "propertyName": "jobUrl",
          "label": "SPARK JOB",
          "tooltip": "View in Spark web UI",
          "group": "spark",
          "values": [
            "http://172.16.14.143:4040/jobs/job?id=59",
            "http://172.16.14.143:4040/jobs/job?id=60",
            "http://172.16.14.143:4040/jobs/job?id=61",
            "http://172.16.14.143:4040/jobs/job?id=62"
          ],
          "interpreterSettingId": "spark"
        }
      },
      "apps": [],
      "jobName": "paragraph_1533679361432_951558601",
      "id": "20180731-121808_1178163107",
      "dateCreated": "2018-08-07 17:02:41.432",
      "dateStarted": "2018-08-07 19:52:16.208",
      "dateFinished": "2018-08-07 19:52:19.267",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\nLet's see what happens if we pass a pattern to analyze only alphabetic characters:",
      "user": "anonymous",
      "dateUpdated": "2018-08-07 19:52:19.287",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "colWidth": 12.0,
        "editorMode": "ace/mode/markdown",
        "fontSize": 9.0,
        "editorHide": true,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>Let&rsquo;s see what happens if we pass a pattern to analyze only alphabetic characters:</p>\n</div>"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533679361432_2017726884",
      "id": "20180802-112524_1955139589",
      "dateCreated": "2018-08-07 17:02:41.432",
      "dateStarted": "2018-08-07 19:52:19.303",
      "dateFinished": "2018-08-07 19:52:19.305",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%pyspark\nalphas = count_chars(documents, pattern=r'[a-zA-Z]')\nalphas.show()",
      "user": "anonymous",
      "dateUpdated": "2018-08-07 19:52:19.405",
      "config": {
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12.0,
        "editorMode": "ace/mode/python",
        "fontSize": 9.0,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "+----+------+\n|char| count|\n+----+------+\n|   l|198648|\n|   x|  9810|\n|   g| 96916|\n|   m|127063|\n|   f|120875|\n|   n|369018|\n|   k| 32798|\n|   v| 52378|\n|   e|633818|\n|   o|386867|\n|   h|294681|\n|   z|  3796|\n|   p| 98913|\n|   d|215706|\n|   y| 90481|\n|   w|100831|\n|   c|144972|\n|   u|138732|\n|   i|365638|\n|   q|  4571|\n+----+------+\nonly showing top 20 rows\n\n"
          }
        ]
      },
      "runtimeInfos": {
        "jobUrl": {
          "propertyName": "jobUrl",
          "label": "SPARK JOB",
          "tooltip": "View in Spark web UI",
          "group": "spark",
          "values": [
            "http://172.16.14.143:4040/jobs/job?id=63",
            "http://172.16.14.143:4040/jobs/job?id=64",
            "http://172.16.14.143:4040/jobs/job?id=65",
            "http://172.16.14.143:4040/jobs/job?id=66",
            "http://172.16.14.143:4040/jobs/job?id=67"
          ],
          "interpreterSettingId": "spark"
        }
      },
      "apps": [],
      "jobName": "paragraph_1533679361432_-1269006568",
      "id": "20180731-123400_1738988173",
      "dateCreated": "2018-08-07 17:02:41.432",
      "dateStarted": "2018-08-07 19:52:19.421",
      "dateFinished": "2018-08-07 19:52:22.156",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n### Which are the top 10 longest words and how many of each are there in the dataset?",
      "user": "anonymous",
      "dateUpdated": "2018-08-07 19:52:22.191",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "colWidth": 12.0,
        "editorMode": "ace/mode/markdown",
        "fontSize": 9.0,
        "editorHide": true,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<h3>Which are the top 10 longest words and how many of each are there in the dataset?</h3>\n</div>"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533679361432_-1303851894",
      "id": "20180717-203409_643183981",
      "dateCreated": "2018-08-07 17:02:41.432",
      "dateStarted": "2018-08-07 19:52:22.206",
      "dateFinished": "2018-08-07 19:52:22.208",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\nThe solution to this exercise is very simple if you followed the example during the session, because you already had all the information you needed: words and their counts. All that was missing was to learn how to sort that information by the length of each word. Here's a possible solution:",
      "user": "anonymous",
      "dateUpdated": "2018-08-07 19:52:22.310",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "colWidth": 12.0,
        "editorMode": "ace/mode/markdown",
        "fontSize": 9.0,
        "editorHide": true,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>The solution to this exercise is very simple if you followed the example during the session, because you already had all the information you needed: words and their counts. All that was missing was to learn how to sort that information by the length of each word. Here&rsquo;s a possible solution:</p>\n</div>"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533679361433_576036282",
      "id": "20180717-203515_888976772",
      "dateCreated": "2018-08-07 17:02:41.433",
      "dateStarted": "2018-08-07 19:52:22.329",
      "dateFinished": "2018-08-07 19:52:22.332",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%pyspark\nfrom pyspark.sql.functions import length\n\ndef determine_longest_words(documents, separators_regexp=r'\\s+'):\n    counts = count_words(documents, separators_regexp)\n    word_stats = counts.withColumn('length', length(counts['word']))\n    return word_stats.orderBy(\"length\", ascending=False)",
      "user": "anonymous",
      "dateUpdated": "2018-08-07 19:52:22.433",
      "config": {
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12.0,
        "editorMode": "ace/mode/python",
        "fontSize": 9.0,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": []
      },
      "apps": [],
      "jobName": "paragraph_1533679361433_-242952945",
      "id": "20180717-204024_103052485",
      "dateCreated": "2018-08-07 17:02:41.433",
      "dateStarted": "2018-08-07 19:52:22.449",
      "dateFinished": "2018-08-07 19:52:22.453",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%pyspark\nlongest = determine_longest_words(documents, separators_regexp=r'\\_?\\W+\\_?')\nlongest.show()",
      "user": "anonymous",
      "dateUpdated": "2018-08-07 19:52:22.553",
      "config": {
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12.0,
        "editorMode": "ace/mode/python",
        "fontSize": 9.0,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "+------------------+-----+------+\n|              word|count|length|\n+------------------+-----+------+\n|disproportionately|    2|    18|\n|supersensitiveness|    2|    18|\n|characteristically|    6|    18|\n| constitutionality|    6|    17|\n| contemporaneously|    1|    17|\n| indistinguishable|    2|    17|\n| unapproachability|    1|    17|\n| telecommunication|    1|    17|\n| disfranchisements|    1|    17|\n| superstitiousness|    1|    17|\n| disadvantageously|    1|    17|\n| misunderstandings|    6|    17|\n| conventionalities|    1|    17|\n|  circumstantially|    1|    16|\n|  incomprehensible|   41|    16|\n|  unenforceability|    2|    16|\n|  constitutionally|    3|    16|\n|  irresponsibility|    2|    16|\n|  lymphangioplasty|    3|    16|\n|  insurrectionists|    1|    16|\n+------------------+-----+------+\nonly showing top 20 rows\n\n"
          }
        ]
      },
      "runtimeInfos": {
        "jobUrl": {
          "propertyName": "jobUrl",
          "label": "SPARK JOB",
          "tooltip": "View in Spark web UI",
          "group": "spark",
          "values": [
            "http://172.16.14.143:4040/jobs/job?id=68"
          ],
          "interpreterSettingId": "spark"
        }
      },
      "apps": [],
      "jobName": "paragraph_1533679361433_1370941801",
      "id": "20180717-204053_182287988",
      "dateCreated": "2018-08-07 17:02:41.433",
      "dateStarted": "2018-08-07 19:52:22.569",
      "dateFinished": "2018-08-07 19:52:25.235",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\nAs you can probably guess by looking at the function above, the `withColumn` method on `Dataframe`s returns a new `Dataframe` with an additional column constructed as specified by the second argument. Something interesting to notice is that the expression we're using to build this new column is an invocation to what is called a \"vectorized\" function, -- a function that works not on individual scalar values, but rather on the whole column all at once.",
      "user": "anonymous",
      "dateUpdated": "2018-08-07 19:52:25.333",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "colWidth": 12.0,
        "editorMode": "ace/mode/markdown",
        "fontSize": 9.0,
        "editorHide": true,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>As you can probably guess by looking at the function above, the <code>withColumn</code> method on <code>Dataframe</code>s returns a new <code>Dataframe</code> with an additional column constructed as specified by the second argument. Something interesting to notice is that the expression we&rsquo;re using to build this new column is an invocation to what is called a &ldquo;vectorized&rdquo; function, &ndash; a function that works not on individual scalar values, but rather on the whole column all at once.</p>\n</div>"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533679361433_-760654778",
      "id": "20180717-205357_44291979",
      "dateCreated": "2018-08-07 17:02:41.433",
      "dateStarted": "2018-08-07 19:52:25.349",
      "dateFinished": "2018-08-07 19:52:25.352",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n### Can you find all anagrams sets with at least two words?\n\nRemember that two words are anagrams of each other if they contain the same number of occurrences of each letter.\nFor example: `areAnagrams(\"mar\", “ram”) == true`, but `areAnagrams(\"line\", “nilee”) == false`\n\nConsider the following set of documents:\n\n`documents = [ “car art”, “rat arc” ]`\n\nIn this case, there are two such sets: `[“rat”, “art”]` and `[“car”, “arc”]` because they contain at least two elements. \n\nNow consider the following set of documents:\n\n`documents = [ “wizeline rocks”, “chuck norris” ]`\n\nIn this case, there are no such sets.",
      "user": "anonymous",
      "dateUpdated": "2018-08-07 19:52:25.452",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "colWidth": 12.0,
        "editorMode": "ace/mode/markdown",
        "fontSize": 9.0,
        "editorHide": true,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<h3>Can you find all anagrams sets with at least two words?</h3>\n<p>Remember that two words are anagrams of each other if they contain the same number of occurrences of each letter.<br/>For example: <code>areAnagrams(&quot;mar&quot;, “ram”) == true</code>, but <code>areAnagrams(&quot;line&quot;, “nilee”) == false</code></p>\n<p>Consider the following set of documents:</p>\n<p><code>documents = [ “car art”, “rat arc” ]</code></p>\n<p>In this case, there are two such sets: <code>[“rat”, “art”]</code> and <code>[“car”, “arc”]</code> because they contain at least two elements. </p>\n<p>Now consider the following set of documents:</p>\n<p><code>documents = [ “wizeline rocks”, “chuck norris” ]</code></p>\n<p>In this case, there are no such sets.</p>\n</div>"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533679361433_441570508",
      "id": "20180717-204142_2055449237",
      "dateCreated": "2018-08-07 17:02:41.433",
      "dateStarted": "2018-08-07 19:52:25.468",
      "dateFinished": "2018-08-07 19:52:25.472",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\nThis exercise is much more involved, as it requires to first think of a conceptual solution to find whether two words are anagrams of each other, and then figuring out which functions to use to achieve each intermediate step in the computation. Here's a possible solution:",
      "user": "anonymous",
      "dateUpdated": "2018-08-07 19:52:25.571",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "colWidth": 12.0,
        "editorMode": "ace/mode/markdown",
        "fontSize": 9.0,
        "editorHide": true,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>This exercise is much more involved, as it requires to first think of a conceptual solution to find whether two words are anagrams of each other, and then figuring out which functions to use to achieve each intermediate step in the computation. Here&rsquo;s a possible solution:</p>\n</div>"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533679361434_561659708",
      "id": "20180717-205037_1683333374",
      "dateCreated": "2018-08-07 17:02:41.434",
      "dateStarted": "2018-08-07 19:52:25.587",
      "dateFinished": "2018-08-07 19:52:25.590",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%pyspark\n\ndef anagram_sets(documents, separators_regexp=r'\\s+'):\n    words = to_words(documents, separators_regexp).distinct()\n    anagrams = words.rdd.groupBy(lambda row: tuple(sorted(row.word))) \\\n        .values().map(list) \\\n        .filter(lambda anagrams: len(anagrams) > 1)\n    return anagrams",
      "user": "anonymous",
      "dateUpdated": "2018-08-07 19:52:25.690",
      "config": {
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12.0,
        "editorMode": "ace/mode/python",
        "fontSize": 9.0,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": []
      },
      "apps": [],
      "jobName": "paragraph_1533679361434_488425937",
      "id": "20180717-205305_1979437516",
      "dateCreated": "2018-08-07 17:02:41.434",
      "dateStarted": "2018-08-07 19:52:25.706",
      "dateFinished": "2018-08-07 19:52:25.710",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%pyspark\nanagrams = anagram_sets(documents, separators_regexp='\\_?\\W+\\_?')\nanagrams.take(10)",
      "user": "anonymous",
      "dateUpdated": "2018-08-07 19:52:25.811",
      "config": {
        "editorSetting": {
          "language": "python",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12.0,
        "editorMode": "ace/mode/python",
        "fontSize": 9.0,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "[[Row(word=u'loi'), Row(word=u'oil')], [Row(word=u'niches'), Row(word=u'inches')], [Row(word=u'pills'), Row(word=u'spill')], [Row(word=u'marian'), Row(word=u'marina')], [Row(word=u'es'), Row(word=u'se')], [Row(word=u'edin'), Row(word=u'dine')], [Row(word=u'form'), Row(word=u'from')], [Row(word=u'pots'), Row(word=u'spot'), Row(word=u'post'), Row(word=u'tops'), Row(word=u'stop')], [Row(word=u'notre'), Row(word=u'tenor')], [Row(word=u'largely'), Row(word=u'gallery')]]\n"
          }
        ]
      },
      "runtimeInfos": {
        "jobUrl": {
          "propertyName": "jobUrl",
          "label": "SPARK JOB",
          "tooltip": "View in Spark web UI",
          "group": "spark",
          "values": [
            "http://172.16.14.143:4040/jobs/job?id=69"
          ],
          "interpreterSettingId": "spark"
        }
      },
      "apps": [],
      "jobName": "paragraph_1533679361434_-1653901188",
      "id": "20180717-210544_305761563",
      "dateCreated": "2018-08-07 17:02:41.434",
      "dateStarted": "2018-08-07 19:52:25.830",
      "dateFinished": "2018-08-07 19:52:36.493",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\nLet's break it down line by line. The first line: `words = to_words(documents, separators_regexp).distinct()` just gives you back a list of unique words. Simple enough!",
      "user": "anonymous",
      "dateUpdated": "2018-08-07 19:52:36.531",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "colWidth": 12.0,
        "editorMode": "ace/mode/markdown",
        "fontSize": 9.0,
        "editorHide": true,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>Let&rsquo;s break it down line by line. The first line: <code>words = to_words(documents, separators_regexp).distinct()</code> just gives you back a list of unique words. Simple enough!</p>\n</div>"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533679361435_-1852774738",
      "id": "20180717-205315_131984777",
      "dateCreated": "2018-08-07 17:02:41.435",
      "dateStarted": "2018-08-07 19:52:36.552",
      "dateFinished": "2018-08-07 19:52:36.555",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\nThe following line: `words.rdd.groupBy(lambda word: tuple(sorted(row.word)))` group words as anagrams by proposing a way to figure out whether two words are anagrams of each other-- simply sort their characters and compare the resulting strings!",
      "user": "anonymous",
      "dateUpdated": "2018-08-07 19:52:36.652",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "colWidth": 12.0,
        "editorMode": "ace/mode/markdown",
        "fontSize": 9.0,
        "editorHide": true,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>The following line: <code>words.rdd.groupBy(lambda word: tuple(sorted(row.word)))</code> group words as anagrams by proposing a way to figure out whether two words are anagrams of each other&ndash; simply sort their characters and compare the resulting strings!</p>\n</div>"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533679361435_-1651305435",
      "id": "20180717-210034_442829954",
      "dateCreated": "2018-08-07 17:02:41.435",
      "dateStarted": "2018-08-07 19:52:36.670",
      "dateFinished": "2018-08-07 19:52:36.673",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\nIn the third line: `.values().map(list)` we discard the keys of the previous grouping, because we don't really need them anymore. All we care about is the list of values for each group, which happens to be an \"iterable\", hence the need to call `.map(list)`",
      "user": "anonymous",
      "dateUpdated": "2018-08-07 19:52:36.774",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "colWidth": 12.0,
        "editorMode": "ace/mode/markdown",
        "fontSize": 9.0,
        "editorHide": true,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>In the third line: <code>.values().map(list)</code> we discard the keys of the previous grouping, because we don&rsquo;t really need them anymore. All we care about is the list of values for each group, which happens to be an &ldquo;iterable&rdquo;, hence the need to call <code>.map(list)</code></p>\n</div>"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533679361435_-2012731997",
      "id": "20180717-210148_280669194",
      "dateCreated": "2018-08-07 17:02:41.435",
      "dateStarted": "2018-08-07 19:52:36.792",
      "dateFinished": "2018-08-07 19:52:36.796",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\nFinally, in the last line: `.filter(lambda anagrams: len(anagrams) > 1)` we remove the trivial groups— those that contain just one element.",
      "user": "anonymous",
      "dateUpdated": "2018-08-07 19:52:36.896",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "colWidth": 12.0,
        "editorMode": "ace/mode/markdown",
        "fontSize": 9.0,
        "editorHide": true,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>Finally, in the last line: <code>.filter(lambda anagrams: len(anagrams) &gt; 1)</code> we remove the trivial groups— those that contain just one element.</p>\n</div>"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533679361436_610399985",
      "id": "20180717-210318_673952657",
      "dateCreated": "2018-08-07 17:02:41.436",
      "dateStarted": "2018-08-07 19:52:36.915",
      "dateFinished": "2018-08-07 19:52:36.917",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    }
  ],
  "name": "wordcount-python-exercises-solutions.json",
  "id": "2DKRWQT1M",
  "noteParams": {},
  "noteForms": {},
  "angularObjects": {
    "md:shared_process": [],
    "spark:shared_process": []
  },
  "config": {
    "isZeppelinNotebookCronEnable": false
  },
  "info": {}
}