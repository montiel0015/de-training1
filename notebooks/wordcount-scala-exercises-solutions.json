{
  "paragraphs": [
    {
      "text": "%md\n## \"Word Count\" Exercises Solutions (Scala)\nRemember that the best way to learn is by doing, so if you haven't yet tried to complete the exercises on your own, please give them a try before looking at the solutions.",
      "dateUpdated": "2018-08-02T21:07:21+0000",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "colWidth": 12,
        "editorMode": "ace/mode/markdown",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<h2>&ldquo;Word Count&rdquo; Exercises Solutions (Scala)</h2>\n<p>Remember that the best way to learn is by doing, so if you haven&rsquo;t yet tried to complete the exercises on your own, please give them a try before looking at the solutions.</p>\n</div>"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533244041207_624195742",
      "id": "20180717-203219_1843464497",
      "dateCreated": "2018-08-02T21:07:21+0000",
      "status": "READY",
      "errorMessage": "",
      "progressUpdateIntervalMs": 500,
      "focus": true,
      "$$hashKey": "object:32832"
    },
    {
      "text": "%md\nWe'll begin by loading once again the documents for further processing and reusing the `toWords` and `countWords` functions that we saw during the session:",
      "dateUpdated": "2018-08-02T21:07:21+0000",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "colWidth": 12,
        "editorMode": "ace/mode/markdown",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>We&rsquo;ll begin by loading once again the documents for further processing and reusing the <code>toWords</code> and <code>countWords</code> functions that we saw during the session:</p>\n</div>"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533244041210_623041495",
      "id": "20180717-211511_527465795",
      "dateCreated": "2018-08-02T21:07:21+0000",
      "status": "READY",
      "errorMessage": "",
      "progressUpdateIntervalMs": 500,
      "$$hashKey": "object:32833"
    },
    {
      "text": "import org.apache.spark.sql.Dataset\n\ndef toWords(documents: Dataset[String], separatorsRegexp: String = \"\"\"\\s+\"\"\"): Dataset[String] = {\n    documents.flatMap(doc => doc.split(separatorsRegexp))\n        .map(word => word.toLowerCase)\n        .filter(word => !word.isEmpty)\n}",
      "dateUpdated": "2018-08-02T22:04:41+0000",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "editorHide": false,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "import org.apache.spark.sql.Dataset\ntoWords: (documents: org.apache.spark.sql.Dataset[String], separatorsRegexp: String)org.apache.spark.sql.Dataset[String]\n"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533244041210_623041495",
      "id": "20180717-211731_1841768387",
      "dateCreated": "2018-08-02T21:07:21+0000",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500,
      "$$hashKey": "object:32834",
      "user": "anonymous",
      "dateFinished": "2018-08-02T22:04:42+0000",
      "dateStarted": "2018-08-02T22:04:41+0000"
    },
    {
      "text": "def countWords(documents: Dataset[String], separatorsRegexp: String = \"\"\"\\s+\"\"\") : Dataset[(String, Long)] = {\n    val words = toWords(documents, separatorsRegexp)\n    val counts = words.groupByKey(identity).count()\n    counts\n}",
      "dateUpdated": "2018-08-02T22:04:47+0000",
      "config": {
        "lineNumbers": false,
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "countWords: (documents: org.apache.spark.sql.Dataset[String], separatorsRegexp: String)org.apache.spark.sql.Dataset[(String, Long)]\n"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533244041210_623041495",
      "id": "20180717-211745_1951066762",
      "dateCreated": "2018-08-02T21:07:21+0000",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500,
      "$$hashKey": "object:32835",
      "user": "anonymous",
      "dateFinished": "2018-08-02T22:04:47+0000",
      "dateStarted": "2018-08-02T22:04:47+0000"
    },
    {
      "text": "def loadFile(bucket_file_path: String) = {\n    sc.textFile(bucket_file_path)\n}",
      "dateUpdated": "2018-08-02T22:05:04+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "loadFile: (bucket_file_path: String)org.apache.spark.rdd.RDD[String]\n"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533244041210_623041495",
      "id": "20180731-232114_598900552",
      "dateCreated": "2018-08-02T21:07:21+0000",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500,
      "$$hashKey": "object:32836",
      "user": "anonymous",
      "dateFinished": "2018-08-02T22:05:05+0000",
      "dateStarted": "2018-08-02T22:05:04+0000"
    },
    {
      "text": "val documents = loadFile(\"gs://de-training-input-bucket/words/big.txt\").toDS()\ndocuments.show()",
      "dateUpdated": "2018-08-02T22:05:34+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "documents: org.apache.spark.sql.Dataset[String] = [value: string]\n+--------------------+\n|               value|\n+--------------------+\n|The Project Guten...|\n|by Sir Arthur Con...|\n|(#15 in our serie...|\n|                    |\n|Copyright laws ar...|\n|copyright laws fo...|\n|this or any other...|\n|                    |\n|This header shoul...|\n|Gutenberg file.  ...|\n|header without wr...|\n|                    |\n|Please read the \"...|\n|eBook and Project...|\n|important informa...|\n|how the file may ...|\n|donation to Proje...|\n|                    |\n|                    |\n|**Welcome To The ...|\n+--------------------+\nonly showing top 20 rows\n\n"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533244041211_622656746",
      "id": "20180801-191033_464035631",
      "dateCreated": "2018-08-02T21:07:21+0000",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500,
      "$$hashKey": "object:32838",
      "user": "anonymous",
      "dateFinished": "2018-08-02T22:05:35+0000",
      "dateStarted": "2018-08-02T22:05:34+0000"
    },
    {
      "text": "%md \n### Can you count the number of characters in the set of documents?",
      "dateUpdated": "2018-08-02T21:07:21+0000",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "colWidth": 12,
        "editorMode": "ace/mode/markdown",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<h3>Can you count the number of characters in the set of documents?</h3>\n</div>"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533244041211_622656746",
      "id": "20180730-125350_577688281",
      "dateCreated": "2018-08-02T21:07:21+0000",
      "status": "READY",
      "errorMessage": "",
      "progressUpdateIntervalMs": 500,
      "$$hashKey": "object:32839"
    },
    {
      "text": "%md\nThis is exactly the same problem as the example the instructor demonstrated, only with a slight twist: rather than splitting the text into words, we need to split it into characters. Let's see how we can accomplish this by modifying the above functions:",
      "dateUpdated": "2018-08-02T21:07:21+0000",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "colWidth": 12,
        "editorMode": "ace/mode/markdown",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>This is exactly the same problem as the example the instructor demonstrated, only with a slight twist: rather than splitting the text into words, we need to split it into characters. Let&rsquo;s see how we can accomplish this by modifying the above functions:</p>\n</div>"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533244041213_620348253",
      "id": "20180730-125420_2063509585",
      "dateCreated": "2018-08-02T21:07:21+0000",
      "status": "READY",
      "errorMessage": "",
      "progressUpdateIntervalMs": 500,
      "$$hashKey": "object:32840"
    },
    {
      "text": "import scala.util.matching.Regex\n\ndef toChars(\n    documents: Dataset[String], \n    pattern: Regex = \".\".r) : Dataset[String] = \n{\n    documents\n        .flatMap(doc => doc.split(\"\"))\n        .map(char => char.toLowerCase)\n        .filter(char => pattern.findFirstIn(char) != None)\n}",
      "dateUpdated": "2018-08-02T22:05:43+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "import scala.util.matching.Regex\ntoChars: (documents: org.apache.spark.sql.Dataset[String], pattern: scala.util.matching.Regex)org.apache.spark.sql.Dataset[String]\n"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533244041213_620348253",
      "id": "20180730-130712_353902806",
      "dateCreated": "2018-08-02T21:07:21+0000",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500,
      "$$hashKey": "object:32841",
      "user": "anonymous",
      "dateFinished": "2018-08-02T22:05:44+0000",
      "dateStarted": "2018-08-02T22:05:43+0000"
    },
    {
      "text": "%md\nNotice we added a `pattern` optional parameter that can come in handy if we want to restrict the characters that we analyze.",
      "dateUpdated": "2018-08-02T21:07:21+0000",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "colWidth": 12,
        "editorMode": "ace/mode/markdown",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>Notice we added a <code>pattern</code> optional parameter that can come in handy if we want to restrict the characters that we analyze.</p>\n</div>"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533244041214_621502500",
      "id": "20180731-125435_1882541499",
      "dateCreated": "2018-08-02T21:07:21+0000",
      "status": "READY",
      "errorMessage": "",
      "progressUpdateIntervalMs": 500,
      "$$hashKey": "object:32842"
    },
    {
      "text": "def countChars(\n    documents: Dataset[String],\n    pattern: Regex = \".\".r) : Dataset[(String, Long)] = \n{\n    val chars = toChars(documents, pattern=pattern)\n    val counts = chars.groupByKey(identity).count()\n    counts\n}",
      "dateUpdated": "2018-08-02T22:05:54+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "countChars: (documents: org.apache.spark.sql.Dataset[String], pattern: scala.util.matching.Regex)org.apache.spark.sql.Dataset[(String, Long)]\n"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533244041214_621502500",
      "id": "20180730-131043_1715520435",
      "dateCreated": "2018-08-02T21:07:21+0000",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500,
      "$$hashKey": "object:32843",
      "user": "anonymous",
      "dateFinished": "2018-08-02T22:05:55+0000",
      "dateStarted": "2018-08-02T22:05:54+0000"
    },
    {
      "text": "%md\nLet's give these functions a try:",
      "dateUpdated": "2018-08-02T21:07:21+0000",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "colWidth": 12,
        "editorMode": "ace/mode/markdown",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>Let&rsquo;s give these functions a try:</p>\n</div>"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533244041215_621117751",
      "id": "20180802-112502_1032268612",
      "dateCreated": "2018-08-02T21:07:21+0000",
      "status": "READY",
      "errorMessage": "",
      "progressUpdateIntervalMs": 500,
      "$$hashKey": "object:32844"
    },
    {
      "text": "val chars = countChars(documents)\nchars.show()",
      "dateUpdated": "2018-08-02T22:05:59+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "chars: org.apache.spark.sql.Dataset[(String, Long)] = [value: string, count(1): bigint]\n+-----+--------+\n|value|count(1)|\n+-----+--------+\n|    7|    1890|\n|    ~|       2|\n|    l|  198648|\n|    ;|    3511|\n|    x|    9810|\n|    =|    1764|\n|    <|       2|\n|    ]|     435|\n|    g|   96916|\n|    3|    2492|\n|    8|    2527|\n|    +|      91|\n|    *|     489|\n|    0|    3064|\n|    m|  127063|\n|    !|    4345|\n|    \t|      12|\n|    f|  120875|\n|    5|    2192|\n|    (|    1748|\n+-----+--------+\nonly showing top 20 rows\n\n"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533244041215_621117751",
      "id": "20180731-125616_1021872024",
      "dateCreated": "2018-08-02T21:07:21+0000",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500,
      "$$hashKey": "object:32845",
      "user": "anonymous",
      "dateFinished": "2018-08-02T22:06:07+0000",
      "dateStarted": "2018-08-02T22:05:59+0000"
    },
    {
      "text": "%md\nLet's see what happens if we pass a pattern to analyze only alphabetic characters:",
      "dateUpdated": "2018-08-02T21:07:21+0000",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "colWidth": 12,
        "editorMode": "ace/mode/markdown",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>Let&rsquo;s see what happens if we pass a pattern to analyze only alphabetic characters:</p>\n</div>"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533244041217_1886941632",
      "id": "20180731-125548_884328081",
      "dateCreated": "2018-08-02T21:07:21+0000",
      "status": "READY",
      "errorMessage": "",
      "progressUpdateIntervalMs": 500,
      "$$hashKey": "object:32846"
    },
    {
      "text": "val alphas = countChars(documents, \"[a-zA-Z]\".r)\nalphas.show()",
      "dateUpdated": "2018-08-02T22:06:21+0000",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "alphas: org.apache.spark.sql.Dataset[(String, Long)] = [value: string, count(1): bigint]\n+-----+--------+\n|value|count(1)|\n+-----+--------+\n|    l|  198648|\n|    x|    9810|\n|    g|   96916|\n|    m|  127063|\n|    f|  120875|\n|    n|  369018|\n|    k|   32798|\n|    v|   52378|\n|    e|  633818|\n|    o|  386867|\n|    h|  294681|\n|    z|    3796|\n|    p|   98913|\n|    d|  215706|\n|    y|   90481|\n|    w|  100831|\n|    c|  144972|\n|    u|  138732|\n|    i|  365638|\n|    q|    4571|\n+-----+--------+\nonly showing top 20 rows\n\n"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533244041217_1886941632",
      "id": "20180730-131159_962072403",
      "dateCreated": "2018-08-02T21:07:21+0000",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500,
      "$$hashKey": "object:32847",
      "user": "anonymous",
      "dateFinished": "2018-08-02T22:06:29+0000",
      "dateStarted": "2018-08-02T22:06:21+0000"
    },
    {
      "text": "%md\n### Which are the top 10 longest words and how many of each are there in the dataset?",
      "dateUpdated": "2018-08-02T21:07:21+0000",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "colWidth": 12,
        "editorMode": "ace/mode/markdown",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<h3>Which are the top 10 longest words and how many of each are there in the dataset?</h3>\n</div>"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533244041218_1888095879",
      "id": "20180717-211705_1316930531",
      "dateCreated": "2018-08-02T21:07:21+0000",
      "status": "READY",
      "errorMessage": "",
      "progressUpdateIntervalMs": 500,
      "$$hashKey": "object:32848"
    },
    {
      "text": "%md\nThe solution to this exercise is very simple if you followed the example during the session, since you already had all the information you needed: words and their counts. All that was missing was to learn how to sort that information by the length of each word. Here's a possible solution:",
      "dateUpdated": "2018-08-02T21:07:21+0000",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "colWidth": 12,
        "editorMode": "ace/mode/markdown",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>The solution to this exercise is very simple if you followed the example during the session, since you already had all the information you needed: words and their counts. All that was missing was to learn how to sort that information by the length of each word. Here&rsquo;s a possible solution:</p>\n</div>"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533244041218_1888095879",
      "id": "20180717-211949_34443017",
      "dateCreated": "2018-08-02T21:07:21+0000",
      "status": "READY",
      "errorMessage": "",
      "progressUpdateIntervalMs": 500,
      "$$hashKey": "object:32849"
    },
    {
      "text": "def longestWords(documents: Dataset[String], separatorsRegexp: String = \"\"\"\\s+\"\"\"): Dataset[(Int, String, Long)] = {\n    val words = countWords(documents, separatorsRegexp)\n    words.map { case (word, count) => (word.size, word, count) }\n         .orderBy($\"_1\".desc)\n}",
      "dateUpdated": "2018-08-02T22:06:40+0000",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "editorHide": false,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "longestWords: (documents: org.apache.spark.sql.Dataset[String], separatorsRegexp: String)org.apache.spark.sql.Dataset[(Int, String, Long)]\n"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533244041218_1888095879",
      "id": "20180717-212002_1888821357",
      "dateCreated": "2018-08-02T21:07:21+0000",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500,
      "$$hashKey": "object:32850",
      "user": "anonymous",
      "dateFinished": "2018-08-02T22:06:42+0000",
      "dateStarted": "2018-08-02T22:06:41+0000"
    },
    {
      "text": "val punctuationRegexp = \"\"\"[\\p{Punct}\\s]\"\"\"\nval longest = longestWords(documents, punctuationRegexp)\nlongest.show()",
      "dateUpdated": "2018-08-02T22:06:48+0000",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "punctuationRegexp: String = [\\p{Punct}\\s]\nlongest: org.apache.spark.sql.Dataset[(Int, String, Long)] = [_1: int, _2: string ... 1 more field]\n+---+------------------+---+\n| _1|                _2| _3|\n+---+------------------+---+\n| 18|disproportionately|  2|\n| 18|supersensitiveness|  2|\n| 18|characteristically|  6|\n| 17| constitutionality|  6|\n| 17| contemporaneously|  1|\n| 17| disadvantageously|  1|\n| 17| unapproachability|  1|\n| 17| telecommunication|  1|\n| 17| superstitiousness|  1|\n| 17| indistinguishable|  2|\n| 17| disfranchisements|  1|\n| 17| misunderstandings|  6|\n| 17| conventionalities|  1|\n| 16|  circumstantially|  1|\n| 16|  enthusiastically|  3|\n| 16|  superciliousness|  1|\n| 16|  insurrectionists|  1|\n| 16|  unenforceability|  2|\n| 16|  disfranchisement|  5|\n| 16|  lymphangioplasty|  3|\n+---+------------------+---+\nonly showing top 20 rows\n\n"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533244041218_1888095879",
      "id": "20180717-212100_4676898",
      "dateCreated": "2018-08-02T21:07:21+0000",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500,
      "$$hashKey": "object:32851",
      "user": "anonymous",
      "dateFinished": "2018-08-02T22:06:55+0000",
      "dateStarted": "2018-08-02T22:06:48+0000"
    },
    {
      "text": "%md\nAs you can see, the solution is quite simple. Perhaps the only part that deserves an explanation is the line: `.orderBy($\"_1\".desc)`. The `$` is an operator that turns its operand (in this case `\"_1\"`) into an object of type `org.apache.spark.sql.Column`, and `\"_1\"` is just the default name that `Dataset`s give to fields when you use tuples rather than the `Row` object, as we are doing in this case.",
      "dateUpdated": "2018-08-02T21:07:21+0000",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "colWidth": 12,
        "editorMode": "ace/mode/markdown",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>As you can see, the solution is quite simple. Perhaps the only part that deserves an explanation is the line: <code>.orderBy($&quot;_1&quot;.desc)</code>. The <code>$</code> is an operator that turns its operand (in this case <code>&quot;_1&quot;</code>) into an object of type <code>org.apache.spark.sql.Column</code>, and <code>&quot;_1&quot;</code> is just the default name that <code>Dataset</code>s give to fields when you use tuples rather than the <code>Row</code> object, as we are doing in this case.</p>\n</div>"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533244041218_1888095879",
      "id": "20180717-212123_154082817",
      "dateCreated": "2018-08-02T21:07:21+0000",
      "status": "READY",
      "errorMessage": "",
      "progressUpdateIntervalMs": 500,
      "$$hashKey": "object:32852"
    },
    {
      "text": "%md\n\n### Can you find all anagrams sets with at least two words?\n\nRemember that two words are anagrams of each other if they contain the same number of occurrences of each letter.\nFor example: `areAnagrams(\"mar\", “ram”) == true`, but `areAnagrams(\"line\", “nilee”) == false`\n\nConsider the following set of documents:\n\n`documents = [ “car art”, “rat arc” ]`\n\nIn this case, there are two such sets: `[“rat”, “art”]` and `[“car”, “arc”]` because they contain at least two elements. \n\nNow consider the following set of documents:\n\n`documents = [ “wizeline rocks”, “chuck norris” ]`\n\nIn this case, there are no such sets.",
      "dateUpdated": "2018-08-02T21:07:21+0000",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "colWidth": 12,
        "editorMode": "ace/mode/markdown",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<h3>Can you find all anagrams sets with at least two words?</h3>\n<p>Remember that two words are anagrams of each other if they contain the same number of occurrences of each letter.<br/>For example: <code>areAnagrams(&quot;mar&quot;, “ram”) == true</code>, but <code>areAnagrams(&quot;line&quot;, “nilee”) == false</code></p>\n<p>Consider the following set of documents:</p>\n<p><code>documents = [ “car art”, “rat arc” ]</code></p>\n<p>In this case, there are two such sets: <code>[“rat”, “art”]</code> and <code>[“car”, “arc”]</code> because they contain at least two elements. </p>\n<p>Now consider the following set of documents:</p>\n<p><code>documents = [ “wizeline rocks”, “chuck norris” ]</code></p>\n<p>In this case, there are no such sets.</p>\n</div>"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533244041218_1888095879",
      "id": "20180717-213338_1287781038",
      "dateCreated": "2018-08-02T21:07:21+0000",
      "status": "READY",
      "errorMessage": "",
      "progressUpdateIntervalMs": 500,
      "$$hashKey": "object:32853"
    },
    {
      "text": "%md\nThis exercise is much more involved, as it requires to first think of a conceptual solution to find whether two words are anagrams of each other, and then figuring out which functions to use to achieve each intermediate step in the computation. Here's a possible solution:",
      "dateUpdated": "2018-08-02T21:07:21+0000",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "colWidth": 12,
        "editorMode": "ace/mode/markdown",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>This exercise is much more involved, as it requires to first think of a conceptual solution to find whether two words are anagrams of each other, and then figuring out which functions to use to achieve each intermediate step in the computation. Here&rsquo;s a possible solution:</p>\n</div>"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533244041220_1885787385",
      "id": "20180717-213513_1398409936",
      "dateCreated": "2018-08-02T21:07:21+0000",
      "status": "READY",
      "errorMessage": "",
      "progressUpdateIntervalMs": 500,
      "$$hashKey": "object:32854"
    },
    {
      "text": "def anagramSets(documents: Dataset[String], separatorsRegexp: String = \"\"\"\\s+\"\"\"): Dataset[List[String]] = {\n    val words = toWords(documents, separatorsRegexp).distinct()\n    val anagrams = words.groupByKey(word => word.sorted)\n      .mapGroups((word, anagrams) => anagrams.toList)\n      .filter(anagrams => anagrams.size > 1)\n\n    anagrams\n}",
      "dateUpdated": "2018-08-02T22:07:09+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "anagramSets: (documents: org.apache.spark.sql.Dataset[String], separatorsRegexp: String)org.apache.spark.sql.Dataset[List[String]]\n"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533244041220_1885787385",
      "id": "20180717-213653_1753752118",
      "dateCreated": "2018-08-02T21:07:21+0000",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500,
      "$$hashKey": "object:32855",
      "user": "anonymous",
      "dateFinished": "2018-08-02T22:07:11+0000",
      "dateStarted": "2018-08-02T22:07:10+0000"
    },
    {
      "text": "val anagrams = anagramSets(documents, punctuationRegexp)\nanagrams.show()",
      "dateUpdated": "2018-08-02T22:07:16+0000",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "anagrams: org.apache.spark.sql.Dataset[List[String]] = [value: array<string>]\n+--------------------+\n|               value|\n+--------------------+\n|            [07, 70]|\n|     [467, 647, 476]|\n|          [oka, oak]|\n|[art, rat, tar, tra]|\n|  [boredom, bedroom]|\n|[recourse, resource]|\n|    [corpus, croups]|\n|        [lids, slid]|\n|[125, 521, 512, 2...|\n|    [leaned, leaden]|\n|[please, elapse, ...|\n|[aet, eat, tea, ate]|\n|  [grieved, diverge]|\n|  [whoever, however]|\n|        [more, rome]|\n|          [map, amp]|\n|      [relic, crile]|\n|    [smiled, misled]|\n|          [der, red]|\n|      [slung, lungs]|\n+--------------------+\nonly showing top 20 rows\n\n"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533244041220_1885787385",
      "id": "20180717-214241_1649052576",
      "dateCreated": "2018-08-02T21:07:21+0000",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500,
      "$$hashKey": "object:32856",
      "user": "anonymous",
      "dateFinished": "2018-08-02T22:07:28+0000",
      "dateStarted": "2018-08-02T22:07:16+0000"
    },
    {
      "text": "%md\nLet's break it down line by line. The first line: `val words = toWords(documents, separatorsRegexp).distinct()` just gives you back a list of unique words. Simple enough.",
      "dateUpdated": "2018-08-02T21:07:21+0000",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "colWidth": 12,
        "editorMode": "ace/mode/markdown",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>Let&rsquo;s break it down line by line. The first line: <code>val words = toWords(documents, separatorsRegexp).distinct()</code> just gives you back a list of unique words. Simple enough.</p>\n</div>"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533244041220_1885787385",
      "id": "20180717-213748_1295804378",
      "dateCreated": "2018-08-02T21:07:21+0000",
      "status": "READY",
      "errorMessage": "",
      "progressUpdateIntervalMs": 500,
      "$$hashKey": "object:32857"
    },
    {
      "text": "%md\nThe second line: `val anagrams = words.groupByKey(word => word.sorted)` groups words by anagrams by proposing a way to figure out whether two words are anagrams of each other: simply sort their characters and compare the resulting strings.",
      "dateUpdated": "2018-08-02T21:07:21+0000",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "colWidth": 12,
        "editorMode": "ace/mode/markdown",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>The second line: <code>val anagrams = words.groupByKey(word =&gt; word.sorted)</code> groups words by anagrams by proposing a way to figure out whether two words are anagrams of each other: simply sort their characters and compare the resulting strings.</p>\n</div>"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533244041221_1885402637",
      "id": "20180717-213852_521170903",
      "dateCreated": "2018-08-02T21:07:21+0000",
      "status": "READY",
      "errorMessage": "",
      "progressUpdateIntervalMs": 500,
      "$$hashKey": "object:32858"
    },
    {
      "text": "%md\nIn the third line: `.mapGroups((word, anagrams) => anagrams.toList)` we discard the keys of the previous grouping, since we don't really need them anymore. All we care about is the list of values for each group, which happens to be an \"iterable\", hence the need to call `.toList`",
      "dateUpdated": "2018-08-02T21:07:21+0000",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "colWidth": 12,
        "editorMode": "ace/mode/markdown",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>In the third line: <code>.mapGroups((word, anagrams) =&gt; anagrams.toList)</code> we discard the keys of the previous grouping, since we don&rsquo;t really need them anymore. All we care about is the list of values for each group, which happens to be an &ldquo;iterable&rdquo;, hence the need to call <code>.toList</code></p>\n</div>"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533244041221_1885402637",
      "id": "20180717-213951_1951649187",
      "dateCreated": "2018-08-02T21:07:21+0000",
      "status": "READY",
      "errorMessage": "",
      "progressUpdateIntervalMs": 500,
      "$$hashKey": "object:32859"
    },
    {
      "text": "%md\nFinally, in the last line: `.filter(lambda anagrams: anagrams.size > 1)` we remove the trivial groups, i.e. those that contain just one element.",
      "dateUpdated": "2018-08-02T21:07:21+0000",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "colWidth": 12,
        "editorMode": "ace/mode/markdown",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>Finally, in the last line: <code>.filter(lambda anagrams: anagrams.size &gt; 1)</code> we remove the trivial groups, i.e. those that contain just one element.</p>\n</div>"
          }
        ]
      },
      "apps": [],
      "jobName": "paragraph_1533244041221_1885402637",
      "id": "20180717-214112_288924767",
      "dateCreated": "2018-08-02T21:07:21+0000",
      "status": "READY",
      "errorMessage": "",
      "progressUpdateIntervalMs": 500,
      "$$hashKey": "object:32860"
    }
  ],
  "name": "wordcount-scala-exercises-solutions.json",
  "id": "2DNWJYG4A",
  "angularObjects": {
    "2DMMG5R5U:shared_process": [],
    "2DMT86YGX:shared_process": [],
    "2DPWEQ61Y:shared_process": [],
    "2DMEHY72N:shared_process": [],
    "2DM7364MX:shared_process": [],
    "2DNAV2RDZ:shared_process": [],
    "2DKPGN4BS:shared_process": [],
    "2DM57QEWS:shared_process": [],
    "2DNX77NXA:shared_process": [],
    "2DPMYPEZB:shared_process": [],
    "2DKSKB5FX:shared_process": [],
    "2DN3AXQ6J:shared_process": [],
    "2DK2ZKHE6:shared_process": [],
    "2DPW1ZPP3:shared_process": [],
    "2DPJJPUEP:shared_process": [],
    "2DN7VDD8E:shared_process": [],
    "2DP583F4B:shared_process": [],
    "2DN7TAJ65:shared_process": []
  },
  "config": {
    "looknfeel": "default",
    "personalizedMode": "false"
  },
  "info": {}
}